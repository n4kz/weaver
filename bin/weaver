#!/usr/bin/env node
var red      = '\033[01;31m',
	green    = '\033[01;32m',
	yellow   = '\033[01;33m',
	clear    = '\033[00m';

'use strict';

var Weaver, daemon, command, server,
	ok       = true,
	net      = require('net'),
	resolve  = require('path').resolve,
	optimist = require('optimist'),
	report   = {},
	sprintf  = require('sprintf').sprintf,
	argv     = optimist
		.default('port', 8092)
		.boolean(['help', 'debug', 'nocolor'])
		.usage([
			'Usage:',
			'    $0 [--port <number>] [--config <path>] [--debug] [start]',
			'    $0 [--port <number>] [--config <path>] [--debug] upgrade',
			'    $0 [--port <number>] <restart|stop> [[task|pid], ...]',
			'    $0 [--port <number>] [--nocolor] status',
			'    $0 [--port <number>] exit',
			'',
			'Commands:',
			'    start',
			'        Start daemon if it was not started before',
			'    upgrade',
			'        Change or re-read config file',
			'    restart',
			'        Restart all tasks, task group, task by pid',
			'    stop',
			'        Stop all tasks, task group, task by pid',
			'    status',
			'        Show status for all tasks',
			'    exit',
			'        Stop all tasks and exit',
			''
		].join('\n'))
		.describe({
			config  : 'Configuration file. Required to start daemon with predefined tasks',
			debug   : 'Do not fork and give additional output. Makes sense only for start',
			nocolor : 'Do not use colors for output',
			help    : 'Show help',
			port    : 'Use specified port'
		})
		.argv;

command = argv._[0] || 'start';

if (command === 'start') {
	argv.daemon = true;
}

/* Help requested */
if (argv.help) {
	ok = false;
}

/* Check command */
if (!argv.daemon) {
	switch (command) {
		case 'stop':
		case 'restart':
			break;

		case 'upgrade':
		case 'status':
		case 'exit':
			if (argv._.length !== 1) {
				ok = false;
			}
			break;

		default:
			ok = false;
	}
}

/* Clear colors */
if (argv.nocolor) {
	red    = '';
	green  = '';
	yellow = '';
	clear  = '';
}

if (!ok) {
	optimist.showHelp();
	process.exit(1);
}

if (argv.daemon) {
	var daemon = require('daemon'),
		Weaver = new require('../lib/weaver')(argv.config),
		server = net.createServer();

	Weaver.log = function () {
		console.warn(red + Array.prototype.slice.call(arguments) + clear);
	};

	/* Debug mode */
	if (!argv.debug) {
		daemon.start();
		process.chdir('/');
		process.title = 'weaver';
	}

	/* Signal handlers */
	process
		.on('SIGINT',  Weaver.die)
		.on('SIGTERM', Weaver.die)
		.on('SIGKILL', Weaver.die)
		.on('SIGHUP',  Weaver.config);

	/* Setup control interface */
	server
		.listen(argv.port, 'localhost')
		.on('connection', accept);
} else {
	var response = '',
		data     = command,
		socket   = net.connect({
			port: argv.port
		});

	/* Send arguments */
	switch (command) {
		case 'upgrade':
			if (argv.config) {
				data += '\r\n';
				data += JSON.stringify([resolve(argv.config)]);
			}
			break;

		case 'stop':
		case 'restart':
			data += '\r\n';
			data += JSON.stringify(argv._.slice(1));
			break;
	}

	socket.once('connect', socket.write.bind(socket, data + '\r\n'));

	socket.on('error', function (error) {
		console.log('Could not connect to weaver on port ' + argv.port);
	});

	socket.on('data', function (data) {
		if (data instanceof Buffer) {
			data = data.toString();
		}

		response += data;
	});

	socket.once('end', function () {
		response = JSON.parse(response);

		if (response.status !== 'ok') {
			console.warn(response.message);
			return;
		}

		switch (command) {
			case 'status':
				console.log(
					green + sprintf('%5u', response.pid) + clear +
					' weaver (' + yellow + response.memory + 'K' + clear + ')'
				);
				report[command](response);
				break;
		}
	});
}

function accept (socket) {
	socket.once('data', execute);
}

function execute (data) {
	var parameters = data.toString().replace(/[\r\n]+$/, '').split('\r\n', 2),
		command    = parameters[0],
		tasks      = Weaver.tasks,
		result     = {
			status : 'ok',
			pid    : process.pid,
			memory : process.memoryUsage().rss >> 10
		},
		task, subtasks, name, i, l, subtask, pid;

	try {
		parameters = JSON.parse(parameters[1] || '[]');
	} catch (error) {
		error.message = 'Client error: ' + error.message;
		Weaver.emit('error', error);
		parameters = [];
	}

	switch (command) {
		case 'stop':
		case 'restart':
			/* TODO: Move this to weaver.js */
			for (i = 0, l = parameters.length; i < l; i++) {
				name = String(parameters[i]);

				if (tasks.hasOwnProperty(name)) {
					tasks[name][command]();
				}

				if (name.match(/^\d+$/)) {
					pid = Number(name);
					for (name in tasks) {
						if (tasks.hasOwnProperty(name)) {
							tasks[name][command](pid);
						}
					}
				}
			}

			/* Restart/stop all */
			if (!parameters.length) {
				for (name in tasks) {
					if (tasks.hasOwnProperty(name)) {
						tasks[name][command]();
					}
				}
			}

			Weaver.config();
			break;

		case 'exit':
			Weaver.die();
			break;

		case 'upgrade':
			if (parameters[0]) {
				Weaver.file = parameters[0];
			}

			Weaver.config();
			break;

		case 'status':
			/* TODO: Move this to weaver.js */
			result.tasks = {};

			for (name in tasks) {
				if (!tasks.hasOwnProperty(name)) {
					continue;
				}

				result.tasks[name] = task = {
					count    : tasks[name].count,
					source   : tasks[name].source,
					restart  : tasks[name].restart,
					subtasks : []
				};

				subtasks = tasks[name].subtasks;

				for (i = 0, l = subtasks.length; i < l; i++) {
					subtask = subtasks[i];
					task.subtasks.push(subtask? {
						pid    : subtask.pid,
						args   : subtask.args,
						status : subtask.status,
						time   : subtask.time
					} : null);
				}
			}

			break;

		default:
			result.status  = 'error';
			result.message = 'Unknown command';
	}

	this.end(JSON.stringify(result) + '\r\n');
}

report.status = function (result) {
	var tasks   = result.tasks,
		lname   = 0,
		lsource = 0,
		name, task, subtask, subtasks, i, l, pid, status, color;

	for (name in tasks) {
		if (!tasks.hasOwnProperty(name)) {
			continue;
		}

		/* Find longest name */
		if (name.length > lname) {
			lname = name.length;
		}

		/* Find longest source */
		if (tasks[name].source.length > lsource) {
			lsource = tasks[name].source.length;
		}
	}

	for (name in tasks) {
		if (!tasks.hasOwnProperty(name)) {
			continue;
		}

		task     = tasks[name];
		subtasks = task.subtasks;

		for (i = 0, l = subtasks.length; i < l; i++) {
			pid = subtasks[i].pid;
			status = subtasks[i].status;

			switch (status) {
				case 'D':
				case 'W':
					color = green;
					break;

				case 'S':
				case 'R':
				case 'N':
					color = yellow;
					break;

				default:
					color = red;
			}

			console.log(
				color +
				sprintf('%5u', subtasks[i].pid) +
				clear +
				(color? '' : ' ' + status) +
				sprintf(' %-' + lname + 's %-' + lsource + 's %s', name, task.source, subtasks[i].args.join(' '))
			);
		}
	}
};

/* vim: set ft=javascript : */
