#!/usr/bin/env node
var red      = '\033[01;31m',
	green    = '\033[01;32m',
	yellow   = '\033[01;33m',
	clear    = '\033[00m';

'use strict';

var command,
	ok       = true,
	net      = require('net'),
	resolve  = require('path').resolve,
	dirname  = require('path').dirname,
	exists   = require('fs').existsSync,
	optimist = require('optimist'),
	report   = {},
	sprintf  = require('sprintf').sprintf,
	argv     = optimist
		.boolean(['help', 'debug', 'nocolor', 'version'])
		.default('port', process.env.WEAVER_PORT || 8092)
		.default('debug', !!process.env.WEAVER_DEBUG)
		.usage([
			'Usage:',
			'    weaver [--port <number>] [--config <path>] [--debug]',
			'    weaver [--port <number>] [--config <path>] upgrade',
			'    weaver [--port <number>] <restart|stop> [[task|pid], ...]',
			'    weaver [--port <number>] kill <signal> [[task|pid], ...]',
			'    weaver [--port <number>] [--nocolor] status',
			'    weaver [--port <number>] [--nocolor] dump',
			'    weaver [--port <number>] monitor',
			'    weaver [--port <number>] exit',
			'',
			'Commands:',
			'    upgrade',
			'        Change or re-read config file',
			'    restart',
			'        Restart all tasks, task group, task by pid',
			'    stop',
			'        Stop all tasks, task group, task by pid',
			'    kill',
			'        Send signal to task group or task by pid',
			'    status',
			'        Show status for all tasks',
			'    dump',
			'        Show current weaver configuration',
			'    monitor',
			'        Show log messages from running weaver',
			'    exit',
			'        Stop all tasks and exit',
			''
		].join('\n'))
		.describe({
			config  : 'Configuration file. Required to start daemon with predefined tasks',
			debug   : 'Do not fork and give additional output. Makes sense only for start',
			nocolor : 'Do not use colors for output',
			help    : 'Show help and exit',
			version : 'Show version and exit',
			port    : 'Use specified port'
		})
		.argv;

command = argv._[0];

if (!command) {
	argv.daemon  = true;
	argv.nocolor = true;
}

/* Help requested */
if (argv.help) {
	optimist.showHelp();
	process.exit();
}

/* Show version */
if (argv.version) {
	console.log(require('../package').version);
	process.exit();
}

/* Check command */
if (!argv.daemon) {
	switch (command) {
		case 'kill':
			if (!argv._.length) {
				ok = false;
			}
			break;

		case 'stop':
		case 'restart':
			break;

		case 'upgrade':
		case 'status':
		case 'dump':
		case 'monitor':
		case 'exit':
			if (argv._.length !== 1) {
				ok = false;
			}
			break;

		default:
			ok = false;
	}
}

/* Clear colors */
if (argv.nocolor) {
	red    = '';
	green  = '';
	yellow = '';
	clear  = '';
}

if (!ok) {
	optimist.showHelp();
	process.exit(1);
}

if (argv.daemon) {
	if (!argv.config && exists('weaver.json')) {
		argv.config = 'weaver.json';
	}

	var code   = 0,
		daemon = require((process.env.WEAVER_TEST? '..' : 'weaver') + '/lib/daemon'),
		child  = require('child_process').spawn(daemon, [JSON.stringify({
				config: argv.config? resolve(argv.config) : null,
				port: argv.port,
				debug: argv.debug
			})], {
			detached: !argv.debug,
			stdio: argv.debug? 'inherit' : ['ignore', 'ignore', 'pipe'],
			env: process.env
		});

	if (!argv.debug) {
		child.stderr.on('data', function (data) {
			code = 1;
			process.stderr.write(data.toString());
		});

		setTimeout(function () {
			/* Wait 150ms for possible errors and exit */
			process.exit(code);
		}, 150);

		child.unref();
	}
} else if (command === 'monitor') {
	var udp    = require('dgram').createSocket('udp4'),
		stdout = process.stdout;

	/* Send all UDP messages to STDOUT */
	udp.on('message', stdout.write.bind(stdout));

	udp.bind(argv.port);
} else {
	var response = '',
		data     = command,
		socket   = net.connect(argv.port);

	/* Send arguments */
	switch (command) {
		case 'upgrade':
			if (argv.config) {
				data += '\r\n';
				data += JSON.stringify([resolve(argv.config)]);
			}
			break;

		case 'kill':
		case 'stop':
		case 'restart':
			if (command === 'kill') {
				argv._[1] = argv._[1]
					.replace(/^(?!sig)/i, 'sig')
					.toUpperCase()
			}

			data += '\r\n';
			data += JSON.stringify(argv._.slice(1));
			break;
	}

	socket.once('connect', socket.write.bind(socket, data + '\r\n'));

	socket.on('error', function (error) {
		console.warn('Could not connect to weaver on port ' + argv.port);
		process.exit(1);
	});

	socket.on('data', function (data) {
		if (data instanceof Buffer) {
			data = data.toString();
		}

		response += data;
	});

	socket.once('end', function () {
		response = JSON.parse(response);

		if (response.status !== 'ok') {
			console.warn(response.message);
			return;
		}

		switch (command) {
			case 'status':
				console.log(
					green + sprintf('%5u', response.pid) + clear +
					(argv.nocolor? '  ' : '') +
					sprintf(' %3s', elapsed(response.uptime)) +
					' weaver ' + response.version + ' (' + yellow + response.memory + 'K' + clear + ')'
				);

			case 'dump':
				report[command](response);
				break;
		}
	});
}

report.status = function (result) {
	var tasks   = result.tasks,
		lname   = 0,
		lsource = 0,
		now     = Date.now(),
		name, task, subtasks, i, l, pid, status, color;

	for (name in tasks) {
		if (!tasks.hasOwnProperty(name)) {
			continue;
		}

		/* Find longest name */
		if (name.length > lname) {
			lname = name.length;
		}

		/* Find longest source */
		if (tasks[name].source.length > lsource) {
			lsource = tasks[name].source.length;
		}
	}

	for (name in tasks) {
		if (!tasks.hasOwnProperty(name)) {
			continue;
		}

		task     = tasks[name];
		subtasks = task.subtasks;

		for (i = 0, l = subtasks.length; i < l; i++) {
			pid = subtasks[i].pid;
			status = subtasks[i].status;

			switch (status) {
				case 'D':
				case 'W':
					color = green;
					break;

				case 'S':
				case 'R':
					color = yellow;
					break;

				default:
					color = red;
			}

			console.log(
				color +
				sprintf('%5u', subtasks[i].pid) +
				clear +
				(color? '' : ' ' + status) +
				sprintf(' %3s', elapsed(subtasks[i].uptime)) +
				sprintf(' %-' + lname + 's %-' + lsource + 's %s', name, task.source, subtasks[i].args.join(' '))
			);
		}
	}
};

report.dump = function (result) {
	var inspect = require('util').inspect;

	console.log(inspect(result.config, false, null, !argv.nocolor));
};

function elapsed (delta) {
	delta /= 1000;

	if (delta < 60)         return time(delta, 's');
	if ((delta /= 60) < 60) return time(delta, 'm');
	if ((delta /= 60) < 24) return time(delta, 'h');
	if ((delta /= 24) < 7)  return time(delta, 'd');

	return time(delta / 7, 'w');
}

function time (value, units) {
	return (value << 0 || 1) + units;
}

/* vim: set ft=javascript : */
