#!/usr/bin/env node
var red      = '\033[01;31m',
	green    = '\033[01;32m',
	yellow   = '\033[01;33m',
	clear    = '\033[00m';

'use strict';

var Weaver, daemon, command, server,
	ok       = true,
	net      = require('net'),
	resolve  = require('path').resolve,
	optimist = require('optimist'),
	report   = {},
	sprintf  = require('sprintf').sprintf,
	argv     = optimist
		.default('port', 8092)
		.boolean(['help', 'debug', 'nocolor'])
		.usage([
			'$0 [--port <number>] <status|stop>',
			'$0 [--port <number>] upgrade [path]',
			'$0 [--port <number>] [--config <path>] [--debug] start'
		].join('\n'))
		.describe({
			config  : 'Configuration file. Required to start daemon with predefined tasks',
			debug   : 'Do not fork and give additional output',
			nocolor : 'Do not use colors for output',
			help    : 'Show help',
			port    : 'Use specified port'
		})
		.argv;

command = argv._[0];

if (command === 'start') {
	argv.daemon = true;
	argv._.shift();
}

/* Not enough arguments */
if (process.argv.length == 2) {
	ok = false;
}

/* Help requested */
if (argv.help) {
	ok = false;
}

/* No command */
if (!argv.daemon && !argv._.length) {
	ok = false;
}

/* Daemon and trailing junk */
if (argv.daemon && argv._.length) {
	ok = false;
}

/* Check command */
if (!argv.daemon) {
	switch (command) {
		case 'upgrade':
		case 'status':
		case 'stop':
			/* TODO: check command arguments */
			break;

		default:
			ok = false;
	}
}

/* Clear colors */
if (argv.nocolor) {
	red    = '';
	green  = '';
	yellow = '';
	clear  = '';
}

if (!ok) {
	optimist.showHelp();
	process.exit(1);
}

if (argv.daemon) {
	var daemon = require('daemon'),
		Weaver = new require('../lib/weaver')(argv.config),
		server = net.createServer();

	if (!argv.debug) {
		daemon.start();
		process.title = 'weaver';
	}

	/* Signal handlers */
	process
		.on('SIGINT',  Weaver.die)
		.on('SIGTERM', Weaver.die)
		.on('SIGKILL', Weaver.die)
		.on('SIGHUP',  Weaver.config);

	/* Setup control interface */
	server
		.listen(argv.port, 'localhost')
		.on('connection', accept);
} else {
	var response = '',
		data     = command,
		socket   = net.connect({
			port: argv.port
		});

	/* Send arguments */
	if (argv._.length > 1) {
		if (command === 'upgrade') {
			data += '\r\n';
			data += JSON.stringify([resolve(argv._[1])]);
		}
	}

	socket.once('connect', socket.write.bind(socket, data + '\r\n'));

	socket.on('error', function (error) {
		console.log('Could not connect to weaver on port ' + argv.port);
	});

	socket.on('data', function (data) {
		if (data instanceof Buffer) {
			data = data.toString();
		}

		response += data;
	});

	socket.once('end', function () {
		response = JSON.parse(response);

		if (response.status !== 'ok') {
			console.warn(response.message);
			return;
		}

		switch (command) {
			case 'status':
				console.log(
					green + sprintf('%5u', response.pid) + clear +
					' weaver (' + yellow + response.memory + 'K' + clear + ')'
				);
				report[command](response);
				break;

			default:
				console.dir(response);
		}
	});
}

function accept (socket) {
	socket.once('data', execute);
}

function execute (data) {
	var parameters = data.toString().replace(/[\r\n]+$/, '').split('\r\n', 2),
		command    = parameters[0],
		result     = {
			status : 'ok',
			pid    : process.pid,
			memory : process.memoryUsage().rss >> 10
		},
		tasks, task, subtasks, name, i, l, subtask;

	try {
		parameters = JSON.parse(parameters[1] || '[]');
	} catch (error) {
		Weaver.emit('error', error.message);
		parameters = [];
	}

	switch (command) {
		case 'stop':
			Weaver.die();
			break;

		case 'upgrade':
			if (parameters[0]) {
				Weaver.file = parameters[0];
			}

			Weaver.config();
			break;

		case 'status':
			result.tasks = {};
			tasks        = Weaver.tasks;

			for (name in tasks) {
				if (!tasks.hasOwnProperty(name)) {
					continue;
				}

				result.tasks[name] = task = {
					count    : tasks[name].count,
					source   : tasks[name].source,
					restart  : tasks[name].restart,
					subtasks : []
				};

				subtasks = tasks[name].subtasks;

				for (i = 0, l = subtasks.length; i < l; i++) {
					subtask = subtasks[i];
					task.subtasks.push(subtask? {
						pid  : subtask.pid,
						args : subtask.args,
						time : subtask.time
					} : null);
				}
			}

			break;

		default:
			result.status  = 'error';
			result.message = 'Unknown command';
	}

	this.end(JSON.stringify(result) + '\r\n');
}

report.status = function (result) {
	var tasks   = result.tasks,
		lname   = 0,
		lsource = 0,
		name, task, subtask, subtasks, i, l, pid;

	for (name in tasks) {
		if (!tasks.hasOwnProperty(name)) {
			continue;
		}

		/* Find longest name */
		if (name.length > lname) {
			lname = name.length;
		}

		/* Find longest source */
		if (tasks[name].source.length > lsource) {
			lsource = tasks[name].source.length;
		}
	}

	for (name in tasks) {
		if (!tasks.hasOwnProperty(name)) {
			continue;
		}

		task     = tasks[name];
		subtasks = task.subtasks;

		for (i = 0, l = subtasks.length; i < l; i++) {
			pid = subtasks[i].pid;

			console.log(
				(pid? green : red) +
				sprintf('%5u', subtasks[i].pid) +
				clear +
				sprintf(' %-' + lname + 's %-' + lsource + 's %s', name, task.source, subtasks[i].args.join(' '))
			);
		}
	}
};

/* vim: set ft=javascript : */
